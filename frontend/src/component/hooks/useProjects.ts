import { useState, useEffect, useCallback } from 'react';
import apiClient from  '../../api/apiClient';
import type Project from '../types/project';


// For the form state
interface ProjectFormData {
  name: string;
  status: 'Active' | 'Inactive';
  auto_approve: boolean;
  period_type: 'weekly' | 'bi-monthly' | 'monthly';
  signature_required: boolean;
  start_date?: string;
  end_date?: string;
  // Optional new fields
  client_address?: string;
  project_description?: string;
  // code is system-generated by backend
}

export const useProjects = () => {
  const [projects, setProjects] = useState<Project[]>([]);
  const [inactiveProjects, setInactiveProjects] = useState<Project[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  // State for the modal and form
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingProject, setEditingProject] = useState<Project | null>(null);
  const [formData, setFormData] = useState<Partial<ProjectFormData>>({
    name: '',
    status: 'Active',
    auto_approve: true,
    period_type: 'weekly',
    signature_required: true,
    start_date: '',
    end_date: '',
    client_address: '',
    project_description: '',
  });

  const fetchProjects = useCallback(async () => {
    try {
      setLoading(true);
      const [activeResponse, inactiveResponse] = await Promise.all([
        apiClient.get('/projects/'),
        apiClient.get('/projects/inactive')
      ]);
      // Ensure the response structure is correctly handled
      if (activeResponse.data && Array.isArray(activeResponse.data.projects)) {
        setProjects(activeResponse.data.projects);
      }
      if (inactiveResponse.data && Array.isArray(inactiveResponse.data.projects)) {
        setInactiveProjects(inactiveResponse.data.projects);
      }
      setError(null); // Clear previous errors on success
    } catch (err: any) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchProjects();
  }, [fetchProjects]);

  const handleOpenModal = (project: Project | null) => {
    setEditingProject(project);
    if (project) {
      setFormData({
        ...project,
        start_date: project.start_date?.split('T')[0] || '', // Format for date input
        end_date: project.end_date?.split('T')[0] || '',
        signature_required: (project as any).signature_required ?? true,
      });
    } else {
      // Reset to default for creating a new project
      setFormData({
        name: '',
        status: 'Active',
        auto_approve: true,
        period_type: 'weekly',
        signature_required: true,
        start_date: '',
        end_date: '',
        client_address: '',
        project_description: '',
      });
    }
    setIsModalOpen(true);
  };

  // Open modal pre-filled with an existing project's data, but in create mode
  const handleDuplicate = (project: Project) => {
    // Clear editing mode so Save performs POST
    setEditingProject(null);
    setFormData({
      name: `${project.name}`,
      status: project.status,
      auto_approve: project.auto_approve,
      period_type: project.period_type,
      signature_required: (project as any).signature_required ?? true,
      start_date: project.start_date ? project.start_date.split('T')[0] : '',
      end_date: project.end_date ? project.end_date.split('T')[0] : '',
      client_address: (project as any).client_address || '',
      project_description: (project as any).project_description || '',
    });
    setIsModalOpen(true);
  };

  const handleCloseModal = () => {
    setIsModalOpen(false);
    setEditingProject(null);
  };

  const handleFormChange = (e: React.ChangeEvent<HTMLInputElement | { name?: string; value: unknown }>) => {
    const target = e.target as HTMLInputElement;
    const { name, type } = target;
    const value = type === 'checkbox' ? target.checked : target.value;
    if (name) {
      setFormData((prev) => ({ ...prev, [name]: value }));
    }
  };

  const handleSave = async () => {
    try {
      if (editingProject) {
        // Do not allow code changes on edit unless explicitly provided
        const { /* code, codePrefix, */ ...rest } = formData as any;
        const payload = rest;
        await apiClient.put(`/projects/${editingProject.id}`, payload);
      } else {
        // System-generated code on backend; do not send code/prefix
        const { /* code, codePrefix, */ ...rest } = formData as any;
        const payload = rest;
        await apiClient.post('/projects', payload);
      }
      handleCloseModal();
      fetchProjects(); // Refresh the list
    } catch (err) {
      setError('Failed to save project. Please try again.');
      // You could set an error state for the modal here
    }
  };

  const handleDeactivate = async (id: number) => {
    if (window.confirm('Are you sure you want to deactivate this project?')) {
      try {
        await apiClient.delete(`/projects/${id}`);
        fetchProjects(); // Refresh the list
      } catch (err) {
        setError('Failed to deactivate project. Please try again.');
      }
    }
  };

  const handleReactivate = async (id: number) => {
    if (window.confirm('Are you sure you want to reactivate this project?')) {
      try {
        await apiClient.put(`/projects/${id}`, { status: 'Active' });
        fetchProjects(); // Refresh the list
      } catch (err) {
        setError('Failed to reactivate project. Please try again.');
      }
    }
  };

  return {
    projects,
    inactiveProjects,
    loading,
    error,
    isModalOpen,
    editingProject,
    formData,
    handleOpenModal,
    handleDuplicate,
    handleCloseModal,
    handleFormChange,
    handleSave,
    handleDeactivate,
    handleReactivate,
  };
};
